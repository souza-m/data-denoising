# -*- coding: utf-8 -*-
"""
Created on Wed May 24 15:13:46 2023

@author: souza-m
"""

import numpy as np
import pandas as pd
import matplotlib.pyplot as pl
from sklearn.decomposition import PCA
from sklearn.cluster import KMeans
import wkm
from scipy.interpolate import BSpline, make_interp_spline


# principal curve examples

# air quality data
air = pd.read_csv('data/airquality.csv')
air = air[['Ozone', 'Temp']].dropna()
y = air.values
n = len(y)
m = int(np.sqrt(n))   # choose m < n


# example 1 - m == n
penalty = .01
x, pi, exy_series = wkm.fit(y, m, 'curve', x0=x, pi0=pi, epochs=500, verbose=True, curve_penalty=penalty)

# plot
fig, ax = pl.subplots(figsize=[8, 6])
ax.set_title(f'Curve, penalty = {penalty}')
ax.axis('equal')
ax.scatter(x=y[:,0], y=y[:,1], s=12, marker='s', color='black', alpha=.25)
ax.scatter(x=x[:,0], y=x[:,1], s=12, color='red', alpha=.5)
ax.plot(x[:,0], x[:,1], color='red', alpha=.5)
if plot_transport:
    for i in range(m):
      for j in range(n):
          ax.plot((x[i,0], y[j,0]), (x[i,1], y[j,1]), color='green', alpha=.5, linewidth=20*pi[i,j]*0.1/pi.max())

# spline




# example 2 - m < n
m = 20

# initial position derived from the pca projected points, but reduced
# start with ordered x_pca and join centroids to reduce number of x-points from n to m
pi = np.zeros([m, n])
max_row = 1/m
max_col = 1/n
i = 0
j = 0
total_row = 0.
total_col = 0.
total = 0.
while total < 1 - 1e-6:
    new_w = min(max_row - total_row, max_col - total_col)
    pi[i,j] = new_w
    total_row += new_w
    total_col += new_w
    total += new_w
    if np.isclose(total_row, max_row):
        # step down
        i += 1
        total_row = 0.
    else:
        # step right
        j += 1
        total_col = 0.
bary = x_pca.mean(axis=0)
x = bary + np.dot(pi, x_pca - bary) * n / m

# plot initial position
plot_transport = True
fig, ax = pl.subplots(figsize=[8, 6])
ax.set_title('PCA')
ax.axis('equal')
ax.scatter(x=y[:,0], y=y[:,1], s=12, marker='s', color='black', alpha=.25)
ax.scatter(x=x[:,0], y=x[:,1], s=22, color='red', alpha=.99)
ax.plot(x[:,0], x[:,1], color='red', alpha=.25)
if plot_transport:
    for i in range(m):
      for j in range(n):
          ax.plot((x[i,0], y[j,0]), (x[i,1], y[j,1]), color='green', alpha=.5, linewidth=20*pi[i,j]*0.1/pi.max())
# looks shifted left...

# generate and plot
penalty = .0002
x, pi, exy_series = wkm.fit(y, m, 'curve', x0=x, pi0=pi, epochs=200, verbose=True, curve_penalty=penalty)

fig, ax = pl.subplots(figsize=[8, 6])
ax.set_title(f'Curve, penalty = {penalty}')
ax.axis('equal')
ax.scatter(x=y[:,0], y=y[:,1], s=12, marker='s', color='black', alpha=.25)
ax.scatter(x=x[:,0], y=x[:,1], s=12, color='red', alpha=.5)
ax.plot(x[:,0], x[:,1], color='red', alpha=.5)
if plot_transport:
    for i in range(m):
      for j in range(n):
          ax.plot((x[i,0], y[j,0]), (x[i,1], y[j,1]), color='green', alpha=.5, linewidth=20*pi[i,j]*0.1/pi.max())

# 2.3 - curves with multiple penalties
penalties = [.0001, .0005, .0025, .01, .05]
x_series = []
for curve_penalty in penalties:
    x, pi, exy_series = wkm.fit(y, m, 'curve', x0=x, pi0=pi, epochs=500, verbose=True, curve_penalty=.01*curve_penalty)
    x_series.append(x)

# plot each curve with transport maps
plot_transport = False
for i, x in enumerate(x_series):
    fig, ax = pl.subplots(figsize=[8, 6])
    ax.set_title(f'Curve, penalty = {penalties[i]}')
    ax.axis('equal')
    ax.scatter(x=y[:,0], y=y[:,1], s=12, marker='s', color='black', alpha=.25)
    ax.scatter(x=x[:,0], y=x[:,1], s=12, color='red', alpha=.5)
    ax.plot(x[:,0], x[:,1], color='red', alpha=.5)
    if plot_transport:
        for i in range(m):
          for j in range(n):
              ax.plot((x[i,0], y[j,0]), (x[i,1], y[j,1]), color='green', alpha=.5, linewidth=20*pi[i,j]*0.1/pi.max())

# plot all curves in the same graph, no transport map
fig, ax = pl.subplots(figsize=[8, 6])
ax.set_title('Curves')
ax.axis('equal')
for i in [0, 2, 4]:
    x = x_series[i]
    ax.scatter(x=x[:,0], y=x[:,1], s=12, alpha=.5)
ax.legend([f'penalty = {p}' for p in penalties])
for i in [0, 2, 4]:
    x = x_series[i]
    ax.plot(x[:,0], x[:,1], color='red', alpha=.5)
ax.scatter(x=y[:,0], y=y[:,1], s=12, marker='s', color='black', alpha=.25)


# example 3 - k-means Lloyd's vs bilinear comparison - synthetic data

# 3.1 - Gaussian grid
# visual comparison of centroids generated by Lloyd's (blue) and our method (red)
grid_size = 3
m = grid_size ** 2
nk = 200
n = nk * m
m * n

np.random.seed(1)
r = []
y = []
cov = np.eye(2) / 50
for i in range(grid_size):
    for j in range(grid_size):
        mean = [i, j]
        r.append(np.array(mean))
        p = np.random.multivariate_normal(mean, cov, size=nk)
        y.append(p)
y = np.vstack(y)
r = np.vstack(r)
y[:5,:]
        
# Lloyd's
kmeans = KMeans(n_clusters=m, random_state=0).fit(y)
kc = kmeans.predict(y)
uk = 1. * np.array([(kc == i).sum() for i in set(kc)])
uk /= uk.sum()
x_km = kmeans.cluster_centers_

# bilinear
x, pi, exy_series = wkm.fit(y, m, 'fixed_u', epochs=20, verbose=True)
u = pi.sum(axis=1)
wkc, pi = wkm.wk_classify(y, x, pi = pi)

wkm.report_indices(kc, wkc, y, None, title = 'synthetic')

# plot
fig, ax = pl.subplots(figsize=[8, 6])
ax.set_title('Variable-weights K-means - synthetic grid data')
ax.axis('equal')
ax.scatter(x=y[:,0], y=y[:,1], s=12, marker='s', color='black', alpha=.25)
ax.scatter(x=x[:,0], y=x[:,1], s=60*m*u, color='red', alpha=.75)
ax.scatter(x=x_km[:,0], y=x_km[:,1], s=60*m*uk, color='blue', alpha=.75)


# 3.1 - exponential and Gaussian
# originating distribution (rho) in the x-axis drown from an Exp distribution
# Gaussian noise added
# comparison of proximity to the x-axis
m, n = 20, 500

np.random.seed(1)
r = np.vstack([np.random.exponential(5., n), np.zeros(n)]).T
noise = np.random.multivariate_normal([0., 0.], np.eye(2), size=n)
y = r + noise

# Lloyd's
kmeans = KMeans(n_clusters=m, random_state=0).fit(y)
kc = kmeans.predict(y)
uk = 1. * np.array([(kc == i).sum() for i in range(m)])
uk /= uk.sum()
x_km = kmeans.cluster_centers_

# bilinear
x, pi, exy_series = wkm.fit(y, m, 'fixed_u', epochs=20, verbose=True)
u = pi.sum(axis=1)

# plot
fig, ax = pl.subplots(figsize=[8, 6])
ax.set_title('Variable-weights K-means - synthetic grid data')
ax.axis('equal')
ax.scatter(x=y[:,0], y=y[:,1], s=12, marker='s', color='black', alpha=.25)
ax.scatter(x=x[:,0], y=x[:,1], s=60*m*u, color='red', alpha=.75)
ax.scatter(x=x_km[:,0], y=x_km[:,1], s=60*m*uk, color='blue', alpha=.75)
